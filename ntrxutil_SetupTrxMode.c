/**
 * @file ntrxutil_SetupTrxMode.c
 * @date 2009-Nov-2
 * @author S.Radtke
 * @c (C) 2009 Nanotron Technologies
 * @brief Functions for setting the nanoLOC mode
 *
 * @note BuildNumber = "8350"
 *
 * @note This file contains the source code for the implementation of the
 *    NTRX helper functions
 */
#include "config.h"
#include "ntrxtypes.h"
#include "ntrxutil.h"
#include "ntrxiqpar.h"
#include "nnspi.h"
#include "hwclock.h"
#include "phy.h"

#include "..\Application\delay.h"

extern PhyPIB phyPIB;
#ifndef CONFIG_SIMPLE_DRV
/**
 * @brief sets transmission mode in the transceiver.
 * @param fdma this parameter determines the the mode (fdma or 80 MHz)
 * @param sd this parameter determines the symbol duration between 500ns and 8us)
 * @param sr this parameter determines the symbol rate between 125kbit and 2Mbit)
 *
 * Based on the three parameters the transceiver is initialized.
 * The iq parameter are set and the nanoLOC chip is calibrated.
 *
 */
/**************************************************************************/
void NTRXSetupTrxMode(uint8_t fdma, uint8_t sd, uint8_t sr)
/**************************************************************************/
{
  modeSet.bw = fdma;
  modeSet.sd = sd;
  modeSet.sr = sr;

  if (fdma == NA_80MHz)
  {
    modeSet.fdma = FALSE;//执行这里，2015-06-23
    modeSet.fixnmap = NA_FIX_MODE;

    ntrxShadowReg[NA_RfRxCompValueI_O] &= (uint8_t)(~(0x0f << NA_RfRxCompValueI_LSB));
    ntrxShadowReg[NA_RfRxCompValueI_O] |= (uint8_t)((0x0e << NA_RfRxCompValueI_LSB));
    ntrxShadowReg[NA_RfRxCompValueQ_O] &= (uint8_t)(~(0x0f << NA_RfRxCompValueQ_LSB));
    ntrxShadowReg[NA_RfRxCompValueQ_O] |= (uint8_t)((0x0e << NA_RfRxCompValueQ_LSB));
  }
  else
  {
    modeSet.fdma = TRUE;
    modeSet.fixnmap = NA_FIX_MODE;

    ntrxShadowReg[NA_RfRxCompValueI_O] |= (0x0f << NA_RfRxCompValueI_LSB);
    ntrxShadowReg[NA_RfRxCompValueQ_O] |= (0x0f << NA_RfRxCompValueQ_LSB);
  }

  NTRXSPIWriteByte(NA_RfRxCompValueI_O, ntrxShadowReg[NA_RfRxCompValueI_O]);//地址0x46，值0x0E
  NTRXSPIWriteByte(NA_RfRxCompValueQ_O, ntrxShadowReg[NA_RfRxCompValueQ_O]);//地址0x47，值0x0E

  if (phyPIB.pwrUp == FALSE)
  {
    if (ntrxShadowReg[NA_RamIndex_O] != 0)
    {
      NTRXSPIWriteByte(NA_RamIndex_O, 0);
    }
    NTRXRXEnable(FALSE);

    /* switch off diio functions to save more power*/
    ntrxShadowReg[NA_DioDirection_O] = 0x01;
    NTRXSPIWriteByte(NA_DioDirection_O, ntrxShadowReg[NA_DioDirection_O]);
    NTRXSPIWriteByte(NA_DioPortWe_O, 0xf);
    NTRXSPIWriteByte(NA_DioPortWe_O, 0);
  }
  else
  {
    //phyPIB.rxState = PHY_RX_ON;
    phyPIB.rxState = PHY_TRX_OFF;
    phyPIB.pwrUp = FALSE;
  }
  //
  /* first part of initial register setting */
  ntrxShadowReg[NA_ResetBbClockGate_O] |= (1 << NA_ResetBbClockGate_B);
  ntrxShadowReg[NA_EnableBbCrystal_O] |= (1 << NA_EnableBbCrystal_B);
  NTRXSPIWrite(NA_ResetBbClockGate_O, ntrxShadowReg + NA_ResetBbClockGate_O, 2);//地址0x07，值0x06 01
  delay_nms(5); /* 5 ms */   /* TODO: is this needed?? */
  ntrxShadowReg[NA_ResetBbClockGate_O] &= (uint8_t)(~(1 << NA_ResetBbClockGate_B));
  ntrxShadowReg[NA_EnableBbClock_O] |= (1 << NA_EnableBbClock_B);
  NTRXSPIWrite(NA_ResetBbClockGate_O, ntrxShadowReg + NA_ResetBbClockGate_O, 2);//地址0x07，值0x04 03
  NTRXSPIWriteByte(NA_ResetBbRadioCtrl_O, (1 << NA_ResetBbRadioCtrl_B));//地址0x07，值0x04
  NTRXSPIWriteByte(NA_ResetBbClockGate_O, 0);//地址0x07，值0x00

  if (fdma != NA_22MHzROM)//执行这里
  {
    ntrxShadowReg[NA_CsqUseRam_O] |= (1 << NA_CsqUseRam_B);
    ntrxShadowReg[NA_EnableExtPA_O] |= (1 << NA_EnableCsqClock_B);
  }
  /* Tx Part */
  ntrxShadowReg[NA_TxArqMax_O] = (CONFIG_MAX_ARQ << NA_TxArqMax_LSB);

  ntrxShadowReg[NA_CsqUsePhaseShift_O] &= (uint8_t)(~((1 << NA_CsqUsePhaseShift_B)
                                          | (1 << NA_CsqAsyMode_B)));
  NTRXSPIWrite(NA_TxArqMax_O, ntrxShadowReg + NA_TxArqMax_O, 2);//地址0x3C，值0x30 40

  ntrxShadowReg[NA_EnableLO_O] &= (uint8_t)(~((1 << NA_EnableLO_B) | (1 << NA_EnableLOdiv10_B)));
  ntrxShadowReg[NA_EnableExtPA_O] |= (1 << NA_EnableExtPA_B);
  NTRXSPIWrite(NA_EnableExtPA_O, ntrxShadowReg + NA_EnableExtPA_O, 7);//地址0x42，值0x14 03 3F 3F 0E 0E 73
  ntrxShadowReg[NA_TxScrambEn_O] |= (1 << NA_TxScrambEn_B);
  ntrxShadowReg[NA_TxAddrSlct_O] &= (uint8_t)(~(1 << NA_TxAddrSlct_B));
  NTRXSPIWrite(NA_TxArq_O, ntrxShadowReg + NA_TxArq_O , 7);//地址0x4E，值0x10 00 00 FF 00 00 00

  ntrxShadowReg[NA_RxCrc2Mode_O] |= (NA_RxCrc2ModeTrigOn_BC_C << NA_RxCrc2Mode_B);
  ntrxShadowReg[NA_RxTimeBCrc1Mode_O] &= (uint8_t)(~(NA_RxTimeBCrc1ModeOn_BC_C << NA_RxTimeBCrc1Mode_B));
  NTRXSPIWriteByte(NA_RxArqMode_O, ntrxShadowReg[NA_RxArqMode_O]);//地址0x5A，值0x0A

# ifdef CONFIG_NTRX_SNIFFER //不执行
  ntrxShadowReg[NA_RxAddrMode_O] &= (uint8_t)(~(1 << NA_RxAddrMode_B));
  NTRXSPIWriteByte(NA_RxAddrMode_O, ntrxShadowReg[NA_RxAddrMode_O]);
# endif

  /* enable fast calibration tuning */
  ntrxShadowReg[NA_LoEnableFastTuning_O] =
    (1 << NA_LoEnableFastTuning_B) |
    (1 << NA_LoEnableLsbNeg_B) |
    (4 << NA_LoFastTuningLevel_LSB);
  NTRXSPIWriteByte(NA_LoEnableFastTuning_O, ntrxShadowReg[NA_LoEnableFastTuning_O]);//地址0x1C，值0x19


  if (fdma == NA_80MHz)
  {
    NTRXSetChannel(0);//执行，只是把一个数组初始化了
  }
  else
  {
    NTRXSetChannel(2);//不执行
  }

  NTRXFctCal();

  if (fdma != NA_22MHzROM)
  {
    NTRXSetRxIqMatrix(fdma, sd);//执行
  }
  NTRXSetCorrThreshold(fdma, sd);

  if (fdma != NA_22MHzROM)
  {
    NTRXSetTxIqMatrix(fdma, sd);//写了3个BD
  }

  NTRXSetSyncWord(phyPIB.syncword);//写同步字

# ifdef CONFIG_NTRX_AUTO_RECALIB //不执行
  NTRXAllCalibration();
# endif /* CONFIG_NTRX_AUTO_RECALIB */

  NTRXSetAgcValues(fdma, sd, sr);

  ntrxShadowReg[NA_GateSizeFramesync_O]  = ((NA_GateSize9Slots_VC_C << NA_GateSizeFramesync_LSB)
      | (NA_GateSize9Slots_VC_C << NA_GateSizeUnsync_LSB)
      | (NA_GateSize9Slots_VC_C << NA_GateSizeBitsync_LSB)
      | (1 << NA_GateAdjBitsyncEn_B)
                                           );
  //地址0x5E，值0x7F
  NTRXSPIWriteByte(NA_GateSizeFramesync_O, ntrxShadowReg[NA_GateSizeFramesync_O]);

  PHYInit();
}
#else /*CONFIG_SIMPLE_DRV*/
CONST uint8_t ntrxInitTable[] PROGMEM = /* 80 4000ns */
{
  2, 0x46, 0x0e, 0x0e,
  2, 0x07, 0x06, 0x01,
  254, 5, /* msec */
  2, 0x07, 0x00, 0x03,
  // 2, 0x07, 0x04, 0x03,
  // 7: W 0x07   1: 04
  // 8: W 0x07   1: 00
  2, 0x3c, 0x00, 0x40,
  7, 0x42, 0x14, 0x03, RfTxOutputPower_DEFAULT, RfTxOutputPower_DEFAULT, 0x0e, 0x0e, 0x73,
  7, 0x4e, 0x10, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
  1, 0x5a, 0x0a,
  1, 0x1c, 0x19,
  1, 0x0e, 0x30,
  32, 0x80,
  0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0xFF, 0xC0, 0x1F, 0xC0, 0x7E, 0x07, 0xC1, 0xF0, 0xF8, 0x78, 0x78,
  0xF1, 0xE3, 0x87, 0x1C, 0x63, 0x8C, 0x73, 0x9C, 0xE6, 0x33, 0x99, 0x98, 0xCC, 0xCC, 0xC0, 0x00,

  1, 0x0e, 0x31,
  32, 0x80,
  0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x03, 0xFE, 0x01, 0xFC, 0x0F, 0xC1, 0xF8, 0x3C, 0x1E, 0x1E, 0x1E,
  0x3C, 0x78, 0xE3, 0x8E, 0x38, 0xC7, 0x38, 0xC6, 0x73, 0x99, 0xCC, 0xCE, 0x66, 0x66, 0x60, 0x00,

  1, 0x0e, 0x32,
  5, 0x80, 0x00, 0x8d, 0x8d, 0x8d, 0x8d,
  1, 0x0e, 0x20,
  1, 0x3d, 0x60,

  128, 0x80,
  0xE0, 0xDF, 0x20, 0x20, 0xDF, 0xDF, 0x60, 0x21, 0x9F, 0x9D, 0xA0, 0x63, 0x1E, 0x5B, 0x21, 0xE5,
  0x9E, 0xD8, 0xA1, 0xA9, 0x1F, 0xD5, 0xDE, 0xEC, 0x63, 0x92, 0x19, 0x2D, 0xEA, 0x53, 0xD0, 0xA9,
  0x73, 0x9B, 0xC9, 0x5D, 0x77, 0x6A, 0x8B, 0x4D, 0x6E, 0x79, 0x9B, 0x03, 0xD8, 0x7A, 0x73, 0x8E,
  0xC3, 0x63, 0xFE, 0x2C, 0x07, 0x45, 0x69, 0x7F, 0x68, 0x05, 0xC7, 0x6A, 0x7F, 0xAA, 0x07, 0xC5,
  0xA6, 0x3F, 0x6F, 0x8C, 0xC1, 0x9C, 0xFB, 0x78, 0x17, 0xC0, 0xCE, 0x30, 0x3F, 0x29, 0x49, 0x02,
  0x5C, 0xFA, 0xFB, 0xDF, 0x03, 0x86, 0xA3, 0xFC, 0x39, 0x1C, 0x03, 0x86, 0x62, 0xFC, 0xFA, 0x60,
  0x05, 0x03, 0x5A, 0xB6, 0x3E, 0x6C, 0x0F, 0xC0, 0x4C, 0x27, 0xFD, 0x3A, 0x63, 0x89, 0x40, 0x4F,
  0xAB, 0xFD, 0x7A, 0xE4, 0xCB, 0xC0, 0x8B, 0x24, 0xB9, 0x7E, 0xEF, 0xD6, 0x03, 0x02, 0x92, 0x6B,


  116, 0x80,
  0xFC, 0xFD, 0xAD, 0xD6, 0x04, 0x81, 0x4E, 0xE5, 0x78, 0x3F, 0x76, 0x23, 0x8E, 0x01, 0x43, 0xD1,
  0x26, 0x78, 0xBF, 0xB9, 0xE9, 0x15, 0x45, 0x80, 0x87, 0x16, 0xA9, 0x78, 0xBF, 0x7B, 0x6D, 0xDC,
  0x8C, 0x02, 0x01, 0x09, 0x18, 0x28, 0xF6, 0xFE, 0xFE, 0x36, 0x68, 0x99, 0x8B, 0x02, 0x80, 0x45,
  0x4F, 0xDC, 0x2A, 0xB6, 0xFD, 0xBF, 0x3B, 0xB3, 0xA8, 0x5B, 0xD0, 0xC7, 0x01, 0x40, 0x83, 0x8A,
  0x13, 0xDE, 0x68, 0xB2, 0x39, 0xFD, 0xFF, 0x3E, 0xF9, 0xF3, 0xEB, 0xE3, 0x9B, 0xD3, 0x4C, 0x06,
  0x42, 0x00, 0x40, 0xC1, 0x84, 0x88, 0xCD, 0x52, 0xD8, 0x1D, 0xA3, 0xE8, 0xED, 0xF1, 0xF5, 0x78,
  0x3B, 0x7C, 0xBE, 0xFF, 0xFF, 0xFF, 0xBF, 0xBE, 0x7E, 0x3D, 0xFC, 0xBB, 0xBA, 0x79, 0x38, 0xF8,
  0xF7, 0xB7, 0xB6, 0xB6,

  1, 0x3d, 0x60,
  1, 0x0e, 0x21,

  128, 0x80,
  0xF7, 0xF7, 0x08, 0xF8, 0xF7, 0x07, 0x18, 0xF8, 0xE7, 0x07, 0x28, 0xF8, 0xC7, 0x17, 0x59, 0xE8,
  0x96, 0x16, 0x89, 0xF9, 0x66, 0xF5, 0xB9, 0x2A, 0x36, 0xA4, 0xD9, 0x8C, 0x27, 0x33, 0xB6, 0x1C,
  0x8A, 0xB3, 0x13, 0x7B, 0x6D, 0x96, 0x11, 0x27, 0x6E, 0x5B, 0x42, 0xE2, 0xCA, 0xDF, 0x98, 0x70,
  0xA3, 0xED, 0x4E, 0x36, 0xB0, 0x15, 0xEE, 0xFE, 0x15, 0xE0, 0x35, 0xDE, 0xFE, 0x25, 0xC0, 0x04,
  0xED, 0x5F, 0x47, 0x70, 0x82, 0xFB, 0xFF, 0xCA, 0x12, 0xB0, 0xA7, 0xAF, 0xCE, 0x26, 0xA0, 0xA3,
  0xFB, 0x1F, 0x0B, 0x03, 0x10, 0x24, 0xFC, 0xCF, 0xCB, 0x03, 0x30, 0x24, 0xFC, 0xEF, 0xFB, 0x04,
  0xE0, 0xC3, 0xFA, 0x5F, 0x9E, 0x27, 0x51, 0xE0, 0x86, 0xED, 0xBF, 0xFC, 0x05, 0xA0, 0x41, 0xB7,
  0xDD, 0xAF, 0xFC, 0x05, 0x80, 0x00, 0x75, 0xFC, 0x1F, 0x8E, 0x48, 0x12, 0x20, 0xA2, 0xC7, 0xDD,

  116, 0x80,
  0xCF, 0x5D, 0x38, 0x22, 0x00, 0x71, 0xA6, 0xFB, 0x3F, 0xEF, 0xAB, 0x06, 0x61, 0x70, 0xC2, 0xC6,
  0xEC, 0x4F, 0x0F, 0xDC, 0x17, 0x23, 0xE0, 0x10, 0x33, 0xE8, 0xDC, 0x3F, 0x1F, 0x0D, 0x39, 0x04,
  0x71, 0x50, 0x71, 0x64, 0xE8, 0xEC, 0x5E, 0x7F, 0x7E, 0x9C, 0x18, 0x14, 0x71, 0x30, 0x20, 0x02,
  0xA5, 0xF8, 0xDC, 0x6E, 0xBF, 0xEF, 0x1E, 0x7B, 0x18, 0x05, 0x42, 0xC0, 0x70, 0x20, 0xD1, 0x63,
  0xC6, 0xF8, 0xEB, 0x9D, 0x2F, 0x9F, 0x0F, 0x6F, 0xED, 0x7B, 0x29, 0x07, 0x05, 0x33, 0x72, 0xD1,
  0x30, 0xB0, 0x20, 0x90, 0xF1, 0x42, 0x93, 0xC5, 0xE6, 0xF8, 0xF9, 0xEA, 0xCB, 0x9C, 0x7D, 0x3E,
  0x0F, 0xCF, 0x8F, 0x5F, 0x1F, 0xEF, 0xBF, 0x8F, 0x6F, 0x4F, 0x2E, 0x0E, 0xEE, 0xDE, 0xCE, 0xBD,
  0xBD, 0xAD, 0xAD, 0x9D,

  1, 0x3d, 0x60,
  1, 0x0e, 0x22,

  128, 0x80,
  0x7D, 0x81, 0x82, 0x7D, 0x7D, 0x82, 0x82, 0x79, 0x79, 0x8A, 0x86, 0x71, 0x75, 0x92, 0x8A, 0x69,
  0x71, 0x9A, 0x96, 0x65, 0x61, 0x9D, 0xA6, 0x66, 0x4D, 0x95, 0xBE, 0x76, 0x39, 0x79, 0xCA, 0x9B,
  0x35, 0x48, 0xBE, 0xCF, 0x56, 0x1C, 0x89, 0xEB, 0xA3, 0x1D, 0x34, 0xC5, 0xEB, 0x6A, 0x04, 0x58,
  0xEA, 0xDB, 0x46, 0x04, 0x78, 0xF7, 0xCB, 0x31, 0x08, 0x84, 0xFB, 0xCB, 0x35, 0x04, 0x78, 0xF3,
  0xD7, 0x4A, 0x00, 0x58, 0xE2, 0xEF, 0x76, 0x08, 0x28, 0xB1, 0xFF, 0xB7, 0x2D, 0x04, 0x64, 0xE2,
  0xF3, 0x87, 0x11, 0x14, 0x89, 0xF3, 0xE7, 0x72, 0x08, 0x18, 0x8D, 0xF3, 0xEB, 0x7A, 0x10, 0x10,
  0x74, 0xE2, 0xF7, 0xA3, 0x2D, 0x00, 0x3C, 0xB1, 0xFB, 0xDF, 0x76, 0x14, 0x08, 0x58, 0xC6, 0xFF,
  0xD7, 0x72, 0x14, 0x04, 0x4C, 0xB6, 0xFB, 0xEB, 0x97, 0x35, 0x00, 0x20, 0x79, 0xD6, 0xFF, 0xDB,

  116, 0x80,
  0x86, 0x29, 0x00, 0x1C, 0x71, 0xCA, 0xFB, 0xEF, 0xA7, 0x4D, 0x0C, 0x04, 0x34, 0x89, 0xD6, 0xFF,
  0xEB, 0xAF, 0x5A, 0x18, 0x00, 0x1C, 0x5C, 0xAA, 0xE7, 0xFF, 0xE7, 0xAB, 0x62, 0x21, 0x00, 0x08,
  0x38, 0x79, 0xBE, 0xEF, 0xFF, 0xEB, 0xBF, 0x7E, 0x41, 0x10, 0x00, 0x0C, 0x34, 0x69, 0xA6, 0xDB,
  0xF7, 0xFF, 0xEB, 0xC7, 0x92, 0x5D, 0x2D, 0x0C, 0x00, 0x08, 0x20, 0x44, 0x75, 0xA2, 0xCA, 0xEB,
  0xFB, 0xFF, 0xF3, 0xDB, 0xBB, 0x92, 0x6E, 0x49, 0x28, 0x10, 0x04, 0x00, 0x04, 0x14, 0x28, 0x40,
  0x5D, 0x79, 0x96, 0xB2, 0xCA, 0xDF, 0xEF, 0xF7, 0xFF, 0xFF, 0xFB, 0xF7, 0xEF, 0xE3, 0xD7, 0xC7,
  0xBB, 0xAA, 0x9E, 0x8E, 0x82, 0x75, 0x69, 0x5D, 0x55, 0x4D, 0x45, 0x3D, 0x38, 0x34, 0x30, 0x2C,
  0x28, 0x28, 0x28, 0x24,

  1, 0x0e, 0x00,
  // 8, 0x2a, 0xab, 0x69, 0xca, 0x94, 0x92, 0xd5, 0x2c, 0xab,
  1, 0x4a, 0x00,
  1, 0x5c, 0x05,
  1, 0x25, 0xde,
  1, 0x43, 0x00,
  1, 0x5e, 0xd5,
  1, 0x48, 0x73,
  1, 0x5e, 0x7f,

  //cbo: changes on request from cg for better getRssi results
  6, 0x1F, 80, 22, 0x7F, 16, 0xFF, 0x0B,

  // 1, 0x42, 0x14,
  // 6, 0x0f, 0x03, 0x3f, 0x7f, 0x00, 0x04, 0x04,

  0, 0 /* End marker */
};
#endif /*CONFIG_SIMPLE_DRV*/



#ifdef CONFIG_SIMPLE_DRV
/**************************************************************************/
void NTRXProcessList(void)
/**************************************************************************/
{
  uint8_t *p;
  uint8_t len, start;
  uint8_t value;

  p = ntrxInitTable;
  do
  {
    len = ReadRomByte(*p);
    p++;
    start = ReadRomByte(*p);
    p++;
    switch (len)
    {
      case 0:
        break;

      case 1:
        value = ReadRomByte(*p);
        p++;
        NTRXSPIWriteByte(start, value);
        break;

      case 254:
        delay_nms(start);
        break;

      case 255:
        delay_nus(start);
        break;

      default:
        NTRXSPIWriteFlash(start, p, len);
        p += len;
        break;
    }
  }
  while (len != 0);
}
#endif /*CONFIG_SIMPLE_DRV*/



#ifdef CONFIG_SIMPLE_DRV
/**************************************************************************/
void NTRXSetupTrxMode(uint8_t fdma, uint8_t sd, uint8_t sr)
/**************************************************************************/
{
  modeSet.bw = fdma;
  modeSet.sd = sd;
  modeSet.sr = sr;

  NTRXSetChannel(0);
  NTRXProcessList();

  NTRXFctCal();
# ifdef CONFIG_NTRX_AUTO_RECALIB
  NTRXAllCalibration();
# endif /* CONFIG_NTRX_AUTO_RECALIB */

  PHYInit();
  NTRXSetSyncWord(phyPIB.syncword);
}
#endif /* CONFIG_SIMPLE_DRV */
